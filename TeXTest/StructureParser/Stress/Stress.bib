@Preamble{
	"\hyphenation{}"
}
% -----------------------------------------------------------------------------
% Folgende entry types machen aus Großbuchstaben im Titel Kleinbuchstaben:
% article
% booklet
% inproceedings
% techreport "bla, bla,...
% -----------------------------------------------------------------------------
@String{pub-AW	= "Ad{\-d}i{\-s}on-Wes{\-l}ey"}
@String{pub-MH	= "Mc{\-}Graw-Hill"}
@String{pub-MS	= "Micro{\-}soft Press"}
@String{pub-ORA	= "O'Reilly \& {Associates, Inc.}"}
@String{pub-PH	= "Pren{\-}tice-Hall"}
@String{pub-JW	= "John Wiley \& {Sons, Inc.}"}
% -----------------------------------------------------------------------------

@manual{Bach:2003:HST,
	author =	"James Bach",
	title =		"Heuristics of Software Testability",
	organization = "Satisfice, Inc.",
	year =		"2003",
	address =	"\url{http://satisfice.com/tools/testable.pdf}"
}

@unpublished{Fritsch:2004:PLT,
	author =	"Claudia Fritsch",
	title =		"How Can Testing Keep Pace with Accelerated Development in Software Product Line Engineering?",
	year =		"2004",
	note =		"Position Statement at the 3rd Software Product Line Conference (SPLC 2004)"
}

@inproceedings{Jungmayr:1999:RSA,
	author =	"Stefan Jungmayr",
	title =		"Reviewing Software Artifacts for Testability",
	booktitle = "Proceedings of the EuroSTAR99, Barcelona, Spain",
	year =		"1999"
}

@inproceedings{Jungmayr:2002:DFT,
	author =	"Stefan Jungmayr",
	title =		"Design for Testability",
	booktitle =	"Proceedings of CONQUEST 2002, Nürnberg",
	year =		"2002",
	pages =		"57--64",
}

@COMMENT{{This file has been generated by bib2bib 1.43}}

@COMMENT{{Command line: /home/users1/csweb/publications_generation_dir/bibtex2html/bib2bib -oc reportkeys -ob publications.bib -c BostonCollegeComputerScience="yes" bibtex/macros.bib bibtex/bibliography.bib bibtex/conferences.bib}}

@PREAMBLE{{
  \newcommand{\bibnoop}[1]{}
  \newcommand{\bibvonmagic}[2]{#2}
  \newcommand{\bibsingleletter}[1]{#1}
}}

@BOOK{Clote:CMB2000,
  AUTHOR = {Peter Clote and R. Backofen},
  TITLE = {Computational Molecular Biology: An Introduction},
  YEAR = {2000},
  MONTH = {Aug},
  PUBLISHER = {John Wiley & Sons, Ltd},
  ISBN = {0-471-87251-2},
  ISBN = {0-471-87252-0},
  DOCUMENTURL = {http://www.cs.bc.edu/~clote/computationalBiologyTableOfContents.html},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@BOOK{Clote:BFMC2000,
  AUTHOR = {Peter Clote and E. Kranakis},
  TITLE = {Boolean Functions and Models of Computation},
  YEAR = {2000},
  MONTH = {Sep},
  PUBLISHER = {Springer-Verlag},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@BOOK{Clote:CSL2000,
  AUTHOR = {Peter Clote},
  TITLE = {Computer Science Logic},
  YEAR = {2000},
  MONTH = {Aug},
  PUBLISHER = {Springer-Verlag},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@BOOK{Clote:TR2000,
  AUTHOR = {R. Fraissé},
  TITLE = {Theory of Relations},
  YEAR = {1986},
  PUBLISHER = {North Holland},
  NOTE = {Research monograph translation by Peter Clote: French to English},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@BOOK{Clote:APTCC1993,
  AUTHOR = {Peter Clote and J. Krajicek},
  TITLE = {Arithmetic, Proof Theory and Computational Complexity},
  YEAR = {1993},
  PUBLISHER = {Oxford University Press},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@BOOK{Clote:FMII1995,
  AUTHOR = {Peter Clote and J. Remmel},
  TITLE = {Feasible Mathematics II},
  YEAR = {1995},
  PUBLISHER = {Birkhäuser Inc},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:RMTAGT1998,
  AUTHOR = {Peter Clote and J. Hirst},
  TITLE = {Reverse mathematics of some topics from algorithmic graph theory},
  JOURNAL = {Fundamenta Mathematica},
  VOLUME = {157},
  NUMBER = {1},
  PAGES = {1-13},
  YEAR = {1998},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:NDSRM1997,
  AUTHOR = {Peter Clote},
  TITLE = {Nondeterministic stack register machines},
  JOURNAL = {Theoretical Computer Science},
  VOLUME = {178},
  PAGES = {37-76},
  YEAR = {1997},
  MONTH = {Jun},
  PS = {http://www.cs.bc.edu/~clote/pub/stackRegister.ps},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:NMC1996,
  AUTHOR = {Peter Clote},
  TITLE = {Note on monotonic complexity of 2-REF},
  JOURNAL = {Information Processing Letters},
  VOLUME = {57},
  PAGES = {117-123},
  YEAR = {1996},
  PS = {http://www.cs.bc.edu/~clote/pub/monotonic.ps},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:CPCTL1995,
  AUTHOR = {Peter Clote and S. Buss},
  TITLE = {Cutting planes, connectivity and threshold logic},
  JOURNAL = {Archive for Mathematical Logic},
  VOLUME = {35},
  PAGES = {33-62},
  YEAR = {1995},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:CPFP1995,
  AUTHOR = {Peter Clote},
  TITLE = {Cutting plane and Frege proofs},
  JOURNAL = {Information and Computation},
  VOLUME = {121},
  NUMBER = {1},
  PAGES = {103-122},
  YEAR = {1995},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:ACSAC1992,
  AUTHOR = {Peter Clote},
  TITLE = {ALOGTIME and a conjecture of S.A. Cook},
  JOURNAL = {Annals of Mathematics and Artificial Intelligence},
  VOLUME = {6},
  PAGES = {57-106},
  YEAR = {1992},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:BANCALN1992,
  AUTHOR = {Peter Clote and G. Takeuti},
  TITLE = {Bounded arithmetic for NC, ALOGTIME, L and NL},
  JOURNAL = {Annals of Pure and Applied Logic},
  VOLUME = {56},
  PAGES = {73-117},
  YEAR = {1992},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:TSHBPP1992,
  AUTHOR = {Peter Clote},
  TITLE = {A time-space hierarchy between P and PSPACE},
  JOURNAL = {Mathematical Systems Theory},
  VOLUME = {25},
  PAGES = {77-92},
  YEAR = {1992},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:SFCSA1991,
  AUTHOR = {Peter Clote and P. Hájek and J. Paris},
  TITLE = {On some formalized consistency statements in arithmetic},
  JOURNAL = {Archive for Mathematical Logic },
  VOLUME = {30},
  NUMBER = {4},
  PAGES = {201-221},
  YEAR = {1991},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:BFIGPC1991,
  AUTHOR = {Peter Clote and E. Kranakis},
  TITLE = {Boolean functions, invariance groups, and parallel complexity},
  JOURNAL = {SIAM J. Comput},
  VOLUME = {20},
  NUMBER = {3},
  PAGES = {553-590},
  YEAR = {1991},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:MSLO1989,
  AUTHOR = {Peter Clote},
  TITLE = {The metamathematics of scattered linear orderings},
  JOURNAL = {Archive for Mathematical Logic},
  VOLUME = {29},
  PAGES = {9-20},
  YEAR = {1989},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:NMST1986,
  AUTHOR = {Peter Clote},
  TITLE = {A note on the MacDowell-Specker Theorem},
  JOURNAL = {Fundamenta Mathematicae},
  VOLUME = {127},
  PAGES = {163-170},
  YEAR = {1986},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@ARTICLE{Clote:MPC1986,
  AUTHOR = {Peter Clote and D. Cenzer and R. Smith and R. Soare and S. Wainer},
  TITLE = {Members of PI01 classes},
  JOURNAL = {Annals of Pure and Applied Logic},
  VOLUME = {31},
  PAGES = {145-161},
  YEAR = {1986},
  BOSTONCOLLEGECOMPUTERSCIENCE = {yes}
}

@InProceedings{wisniewski:in-place,
  author = {Leonard F. Wisniewski},
  title = {Structured Permuting in Place on Parallel Disk Systems},
  booktitle = {Proceedings of the Fourth Workshop on Input/Output in Parallel
  and Distributed Systems},
  year = {1996},
  month = {May},
  pages = {128--139},
  publisher = {ACM Press},
  address = {Philadelphia},
  keywords = {parallel I/O, parallel I/O algorithm, permutation, out-of-core,
  pario-bib},
  abstract = {The ability to perform permutations of large data sets in place
  reduces the amount of necessary available disk storage. The simplest way to
  perform a permutation often is to read the records of a data set from a
  source portion of data storage, permute them in memory, and write them to a
  separate target portion of the same size. It can be quite expensive, however,
  to provide disk storage that is twice the size of very large data sets.
  Permuting in place reduces the expense by using only a small amount of extra
  disk storage beyond the size of the data set. \par
  \newcommand{\ceil}[1]{\lceil #1\rceil} \newcommand{\rank}[1]{\mathop{\rm
  rank}\nolimits #1} This paper features in-place algorithms for commonly used
  structured permutations. We have developed an asymptotically optimal
  algorithm for performing BMMC (bit-matrix-multiply/complement) permutations
  in place that requires at most $\frac{2N}{BD}\left(
  2\ceil{\frac{\rank{\gamma}}{\lg (M/B)}} + \frac{7}{2}\right)$ parallel disk
  accesses, as long as $M \geq 2BD$, where $N$ is the number of records in the
  data set, $M$ is the number of records that can fit in memory, $D$ is the
  number of disks, $B$ is the number of records in a block, and $\gamma$ is the
  lower left $\lg (N/B) \times \lg B$ submatrix of the characteristic matrix
  for the permutation. This algorithm uses $N+M$ records of disk storage and
  requires only a constant factor more parallel disk accesses and insignificant
  additional computation than a previously published asymptotically optimal
  algorithm that uses $2N$ records of disk storage. \par We also give
  algorithms to perform mesh and torus permutations on a $d$-dimensional mesh.
  The in-place algorithm for mesh permutations requires at most $3\ceil{N/BD}$
  parallel I/Os and the in-place algorithm for torus permutations uses at most
  $4dN/BD$ parallel I/Os. The algorithms for mesh and torus permutations
  require no extra disk space as long as the memory size $M$ is at least $3BD$.
  The torus algorithm improves upon the previous best algorithm in terms of
  both time and space.}
}

@Article{thakur:noncontigous,
  author = {Rajeev Thakur and William Gropp and Ewing Lusk},
  title = {Optimizing Noncontiguous Accesses in {MPI-IO}},
  journal = {Parallel Computing},
  year = {2002},
  month = {January},
  volume = {28},
  number = {1},
  pages = {83--105},
  URL = {http://www.mcs.anl.gov/~thakur/papers/mpi-io-noncontig.ps},
  keywords = {parallel I/O, parallel I/O, MPI-IO, collective I/O, data sieving,
  pario-bib},
  abstract = {The I/O access patterns of many parallel applications consist of
  accesses to a large number of small, noncontiguous pieces of data. If an
  application's I/O needs are met by making many small, distinct I/O requests,
  however, the I/O performance degrades drastically. To avoid this problem,
  MPI-IO allows users to access noncontiguous data with a single I/O function
  call, unlike in Unix I/O. In this paper, we explain how critical this feature
  of MPI-IO is for high performance and how it enables implementations to
  perform optimizations. We first provide a classification of the different
  ways of expressing an application's I/O needs in MPI-IO---we classify them
  into four {\em levels}, called level~0 through level~3. We demonstrate that,
  for applications with noncontiguous access patterns, the I/O performance
  improves dramatically if users write their applications to make level-3
  requests (noncontiguous, collective) rather than level-0 requests (Unix
  style). We then describe how our MPI-IO implementation, ROMIO, delivers high
  performance for noncontiguous requests. We explain in detail the two key
  optimizations ROMIO performs: data sieving for noncontiguous requests from
  one process and collective I/O for noncontiguous requests from multiple
  processes. We describe how we have implemented these optimizations portably
  on multiple machines and file systems, controlled their memory requirements,
  and also achieved high performance. We demonstrate the performance and
  portability with performance results for three applications---an
  astrophysics-application template (DIST3D), the NAS BTIO benchmark, and an
  unstructured code (UNSTRUC)---on five different parallel machines: HP
  Exemplar, IBM SP, Intel Paragon, NEC SX-4, and SGI Origin2000.}
}

@InProceedings{reddy:compiler,
  author = {A. L. Narasimha Reddy and P. Banerjee and D. K. Chen},
  title = {Compiler Support for Parallel {I/O} Operations},
  booktitle = {Proceedings of the 1991 International Conference on Parallel
  Processing},
  year = {1991},
  pages = {II:290--II:291},
  publisher = {CRC Press},
  address = {St. Charles, IL},
  earlier = {reddy:compiler-tr},
  keywords = {parallel I/O, pario-bib, compilers},
  comment = {This version is only 2 pages. reddy:compiler-tr provides the full
  text. They discuss three primary issues. 1) Overlapping I/O with computation:
  the compiler's dependency analysis is used to decide when some I/O may be
  moved up and performed asynchronously with other computation. 2) Parallel
  execution of I/O statements: {\em if} all sizes are known at compile time,
  the compiler can insert seeks so that processes can access the file
  independently. When writing in the presence of conditionals they even propose
  skipping by the maximum and leaving holes in the file, and they claim that
  this doesn't hurt (!). 3) Parallel format conversion: again, if there are
  fixed-width fields the compiler can have processors seek to different
  locations, read data independently, and do format conversion in parallel.
  Really all this is saying is that fixed-width fields are good for
  parallelism, and that compilers could take advantage of them.}
}

@TECHREPORT{MSU-CSE-99-39,
  AUTHOR =        {Lin Hong and Anil K. Jain and Sharath Pankanti},
  TITLE =         {Can multibiometrics improve performance},
  NUMBER =        {MSU-CSE-99-39},
  INSTITUTION =   {Department of Computer Science, Michigan State University},
  ADDRESS =       {East Lansing, Michigan},
  ABSTRACT =      {While it is widely acknowledged that the performance
                   improvement in current biometrics-based personal
                   authentication systems is necessary, it is not clear what
                   mechanisms could be used to improve the performance. In this
                   paper, we formulate the problem of multiple biometrics
                   integration and examine whether the improvement in
                   performance could be achieved from integrating multiple
                   biometrics. For two practical and commonly used situations
                   of multibiometric integration, we analyze the performance
                   gains. We also demontrate empirically that integration of
                   multiple biometrics does indeed result in consistent and
                   significant performance improvement.},
  KEYWORDS =      {},
  NOTE =          {},
  MONTH =         {December},
  YEAR  =         {1999},
  AUTHOR1_URL =   {http://www.cse.msu.edu/~jain},
  AUTHOR1_EMAIL = {jain@cse.msu.edu},
  AUTHOR2_URL =   {http://www.cse.msu.edu/~honglin},
  AUTHOR2_EMAIL = {honglin@cse.msu.edu},
  PAGES =         {6},
  FILE  =         {/user/web/htdocs/publications/tech/TR/MSU-CSE-99-39.ps},
  URL   =         {},
  CONTACT =       {jain@cse.msu.edu}
}